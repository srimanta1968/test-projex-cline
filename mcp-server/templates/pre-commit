#!/bin/bash

# ProjexLight MCP Pre-Commit Hook
# Automatically scans staged files for duplicate APIs and components before commit
# This hook is installed automatically by the MCP server on startup

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
MCP_SERVER_URL="${MCP_SERVER_URL:-http://localhost:8766}"
PROJECT_ROOT="/workspace"  # MCP Docker container mounts project root at /workspace

echo -e "${BLUE}ğŸ” ProjexLight Pre-Commit Duplicate Scan${NC}"
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"

# Check if MCP server is running
if ! curl -s "${MCP_SERVER_URL}/health" > /dev/null 2>&1; then
    echo -e "${YELLOW}âš ï¸  MCP server not running at ${MCP_SERVER_URL}${NC}"
    echo -e "${YELLOW}   Pre-commit scan skipped (graceful degradation)${NC}"
    echo -e "${YELLOW}   Start MCP server: cd mcp-server && docker-compose up -d${NC}"
    exit 0
fi

echo -e "${GREEN}âœ“ MCP server is running${NC}"

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || echo "")

if [ -z "$STAGED_FILES" ]; then
    echo -e "${YELLOW}âš ï¸  No files staged for commit${NC}"
    exit 0
fi

# Count staged files
FILE_COUNT=$(echo "$STAGED_FILES" | wc -l)
echo -e "\n${BLUE}ğŸ“‹ Scanning ${FILE_COUNT} staged file(s)...${NC}"

# Convert file list to JSON array
FILES_JSON=$(echo "$STAGED_FILES" | jq -R -s -c 'split("\n")[:-1]')

# Send request to MCP server
SCAN_RESULT=$(curl -s -X POST "${MCP_SERVER_URL}/api/pre-commit-scan" \
    -H "Content-Type: application/json" \
    -d "{\"stagedFiles\": ${FILES_JSON}}" 2>&1)

CURL_EXIT=$?

if [ $CURL_EXIT -ne 0 ]; then
    echo -e "${RED}âŒ Failed to connect to MCP server${NC}"
    echo -e "${YELLOW}   Allowing commit to proceed (graceful degradation)${NC}"
    exit 0
fi

# Parse results
SUCCESS=$(echo "$SCAN_RESULT" | jq -r '.success // false' 2>/dev/null || echo "false")
BLOCKING=$(echo "$SCAN_RESULT" | jq -r '.blocking // false' 2>/dev/null || echo "false")
DUPLICATES_FOUND=$(echo "$SCAN_RESULT" | jq -r '.duplicatesFound // false' 2>/dev/null || echo "false")
DUPLICATE_COUNT=$(echo "$SCAN_RESULT" | jq -r '.duplicates.count // 0' 2>/dev/null || echo "0")
WARNING_COUNT=$(echo "$SCAN_RESULT" | jq -r '.warnings | length // 0' 2>/dev/null || echo "0")
SCANNED_FILES=$(echo "$SCAN_RESULT" | jq -r '.scannedFiles // 0' 2>/dev/null || echo "0")
SUMMARY=$(echo "$SCAN_RESULT" | jq -r '.summary // "Scan completed"' 2>/dev/null || echo "Scan completed")

echo -e "\n${BLUE}ğŸ“Š Scan Results:${NC}"
echo -e "   Files scanned: ${SCANNED_FILES}"

if [ "$DUPLICATES_FOUND" = "true" ]; then
    if [ "$DUPLICATE_COUNT" -gt 0 ]; then
        echo -e "   ${RED}ğŸš¨ Duplicate APIs: ${DUPLICATE_COUNT}${NC}"
    fi

    if [ "$WARNING_COUNT" -gt 0 ]; then
        echo -e "   ${YELLOW}âš ï¸  Similar components: ${WARNING_COUNT}${NC}"
    fi
else
    echo -e "   ${GREEN}âœ“ No duplicates detected${NC}"
fi

# Handle blocking duplicates
if [ "$BLOCKING" = "true" ]; then
    echo -e "\n${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${RED}ğŸš¨ COMMIT BLOCKED: Duplicate APIs detected${NC}"
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"

    # Show duplicate details
    echo -e "\n${RED}Duplicate APIs found:${NC}\n"
    echo "$SCAN_RESULT" | jq -r '.duplicates.apis[] |
        "  ğŸš¨ \(.newAPI.method) \(.newAPI.endpoint)\n" +
        "     File: \(.newAPI.filePath)\n" +
        "     Conflicts with: \(.existingAPI.filePath)\n" +
        "     Sprint: \(.existingAPI.sprintName // "Unknown")\n"'

    echo -e "${YELLOW}Action Required:${NC}"
    echo -e "  1. âœ… Reuse existing API (recommended)"
    echo -e "  2. ğŸ”„ Modify endpoint path to make it unique"
    echo -e "  3. ğŸ“ Add justification comment if duplicate is intentional"
    echo -e ""
    echo -e "${YELLOW}To bypass this check (not recommended):${NC}"
    echo -e "  git commit --no-verify -m \"your message\""
    echo -e ""

    exit 1
fi

# Show warnings (non-blocking)
if [ "$WARNING_COUNT" -gt 0 ]; then
    echo -e "\n${YELLOW}âš ï¸  Component Similarity Warnings (non-blocking):${NC}\n"
    echo "$SCAN_RESULT" | jq -r '.warnings[] |
        "  âš ï¸  \(.component) (\(.filePath))\n" +
        "     Similar to: \(.similarTo) (\(.similarity)% match)\n" +
        "     \(.message)\n"'
    echo -e "${YELLOW}ğŸ’¡ Review these similarities in the Leadership Dashboard${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TASK PROGRESS AUTO-UPDATE
# Parse commit message and update task completion status if not already updated
# Updates both tasks-completed.json (main tracker) and task-N.json (individual task file)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

echo -e "\n${BLUE}ğŸ“Š Checking task progress update...${NC}"

# Get the commit message from .git/COMMIT_EDITMSG if it exists
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")
else
    # Try to get from command line (for --message commits)
    COMMIT_MSG=""
fi

# Parse commit message for task references
# Expected format: "Complete task-N sub-task M: ..." or "task-N sub-task M"
TASK_PATTERN="task-([0-9]+)"
SUBTASK_PATTERN="sub-task[[:space:]]*([0-9]+)"

if [[ $COMMIT_MSG =~ $TASK_PATTERN ]]; then
    TASK_NUM="${BASH_REMATCH[1]}"
    echo -e "   ${GREEN}Found task reference: task-${TASK_NUM}${NC}"

    if [[ $COMMIT_MSG =~ $SUBTASK_PATTERN ]]; then
        SUBTASK_NUM="${BASH_REMATCH[1]}"
        echo -e "   ${GREEN}Found sub-task reference: sub-task ${SUBTASK_NUM}${NC}"

        # Find the config directory and progress files
        CONFIG_DIR=""
        PROGRESS_FILE=""
        TASK_FILE=""

        for config_dir in ".claude" ".goose" ".cursor" ".aider" ".windsurf" ".cline" ".gemini" ".projexlight"; do
            if [ -f "${config_dir}/progress/tasks-completed.json" ]; then
                CONFIG_DIR="${config_dir}"
                PROGRESS_FILE="${config_dir}/progress/tasks-completed.json"
                TASK_FILE="${config_dir}/progress/major-tasks/task-${TASK_NUM}.json"
                break
            fi
        done

        if [ -n "$PROGRESS_FILE" ] && [ -f "$PROGRESS_FILE" ]; then
            echo -e "   ${BLUE}Config directory: ${CONFIG_DIR}${NC}"
            echo -e "   ${BLUE}Progress file: ${PROGRESS_FILE}${NC}"
            echo -e "   ${BLUE}Task file: ${TASK_FILE}${NC}"

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # Read current state from tasks-completed.json
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            CURRENT_MAJOR_INDEX=$(jq -r '.current_major_task_index // 0' "$PROGRESS_FILE" 2>/dev/null || echo "0")
            CURRENT_SUB_INDEX=$(jq -r '.current_sub_task_index // 0' "$PROGRESS_FILE" 2>/dev/null || echo "0")
            TOTAL_SUB_TASKS=$(jq -r '.current_task_summary.total_sub_tasks // 0' "$PROGRESS_FILE" 2>/dev/null || echo "0")

            echo -e "   ${BLUE}Current state: Major task ${CURRENT_MAJOR_INDEX}, Sub-task ${CURRENT_SUB_INDEX}/${TOTAL_SUB_TASKS}${NC}"

            # Check if this commit is for the current major task
            if [ "$TASK_NUM" -eq "$CURRENT_MAJOR_INDEX" ]; then
                # Check if update is needed (sub-task index should be incremented)
                if [ "$CURRENT_SUB_INDEX" -lt "$SUBTASK_NUM" ]; then
                    echo -e "   ${YELLOW}âš ï¸  Progress not updated by LLM - auto-updating...${NC}"
                    echo -e "   ${YELLOW}   current_sub_task_index: ${CURRENT_SUB_INDEX} â†’ ${SUBTASK_NUM}${NC}"

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Update tasks-completed.json (main tracker)
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    TEMP_FILE=$(mktemp)
                    jq --argjson subIdx "$SUBTASK_NUM" \
                       --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                       '.current_sub_task_index = $subIdx |
                        .current_task_summary.completed_sub_tasks = $subIdx |
                        .current_task_summary.pending_sub_tasks = (.current_task_summary.total_sub_tasks - $subIdx) |
                        .last_updated = $timestamp' \
                       "$PROGRESS_FILE" > "$TEMP_FILE" && mv "$TEMP_FILE" "$PROGRESS_FILE"

                    if [ $? -eq 0 ]; then
                        echo -e "   ${GREEN}âœ… tasks-completed.json updated${NC}"
                        git add "$PROGRESS_FILE"
                    else
                        echo -e "   ${RED}âŒ Failed to update tasks-completed.json${NC}"
                    fi

                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Update task-N.json (individual task file)
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if [ -f "$TASK_FILE" ]; then
                        TASK_TEMP=$(mktemp)

                        # Read total sub-tasks from task file
                        TASK_TOTAL_SUBS=$(jq -r '.total_sub_tasks // 0' "$TASK_FILE" 2>/dev/null || echo "0")

                        # Calculate new pending count
                        NEW_PENDING=$((TASK_TOTAL_SUBS - SUBTASK_NUM))
                        if [ "$NEW_PENDING" -lt 0 ]; then
                            NEW_PENDING=0
                        fi

                        # Determine status based on completion
                        if [ "$SUBTASK_NUM" -ge "$TASK_TOTAL_SUBS" ]; then
                            NEW_STATUS="completed"
                            COMPLETED_AT="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                        else
                            NEW_STATUS="in_progress"
                            COMPLETED_AT="null"
                        fi

                        # Update task file
                        jq --argjson subIdx "$SUBTASK_NUM" \
                           --argjson pending "$NEW_PENDING" \
                           --arg status "$NEW_STATUS" \
                           --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                           '.current_sub_task_index = ($subIdx + 1) |
                            .completed_sub_tasks = $subIdx |
                            .pending_sub_tasks = $pending |
                            .in_progress_sub_tasks = (if $status == "completed" then 0 else 1 end) |
                            .status = $status |
                            .started_at = (if .started_at == null then $timestamp else .started_at end)' \
                           "$TASK_FILE" > "$TASK_TEMP" && mv "$TASK_TEMP" "$TASK_FILE"

                        if [ $? -eq 0 ]; then
                            echo -e "   ${GREEN}âœ… task-${TASK_NUM}.json updated (status: ${NEW_STATUS})${NC}"
                            git add "$TASK_FILE"
                        else
                            echo -e "   ${RED}âŒ Failed to update task-${TASK_NUM}.json${NC}"
                        fi

                        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        # Update sub-task status within task file
                        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        # Mark the completed sub-task as "completed"
                        SUB_TEMP=$(mktemp)
                        jq --argjson subNum "$SUBTASK_NUM" \
                           --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                           '(.sub_tasks[] | select(.sequence_number == $subNum)) |= . + {
                              "status": "completed",
                              "completed_at": $timestamp
                            }' \
                           "$TASK_FILE" > "$SUB_TEMP" && mv "$SUB_TEMP" "$TASK_FILE"

                        if [ $? -eq 0 ]; then
                            echo -e "   ${GREEN}âœ… Sub-task ${SUBTASK_NUM} marked as completed${NC}"
                            git add "$TASK_FILE"
                        fi

                        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        # Check if all sub-tasks complete - move to next major task
                        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        if [ "$NEW_STATUS" == "completed" ]; then
                            echo -e "   ${GREEN}ğŸ‰ All sub-tasks complete for task-${TASK_NUM}!${NC}"

                            # Update tasks-completed.json to move to next major task
                            NEXT_MAJOR=$((TASK_NUM + 1))
                            TOTAL_MAJOR=$(jq -r '.total_tasks // 0' "$PROGRESS_FILE" 2>/dev/null || echo "0")

                            if [ "$NEXT_MAJOR" -lt "$TOTAL_MAJOR" ]; then
                                echo -e "   ${BLUE}Moving to next major task: task-${NEXT_MAJOR}${NC}"

                                NEXT_TASK_FILE="${CONFIG_DIR}/progress/major-tasks/task-${NEXT_MAJOR}.json"
                                if [ -f "$NEXT_TASK_FILE" ]; then
                                    NEXT_TOTAL_SUBS=$(jq -r '.total_sub_tasks // 0' "$NEXT_TASK_FILE" 2>/dev/null || echo "0")
                                    NEXT_TITLE=$(jq -r '.title // "Next Task"' "$NEXT_TASK_FILE" 2>/dev/null || echo "Next Task")

                                    # Update main progress file for next task
                                    MAIN_TEMP=$(mktemp)
                                    jq --argjson nextMajor "$NEXT_MAJOR" \
                                       --arg nextFile "task-${NEXT_MAJOR}.json" \
                                       --arg nextPath "${CONFIG_DIR}/progress/major-tasks/task-${NEXT_MAJOR}.json" \
                                       --argjson nextTotalSubs "$NEXT_TOTAL_SUBS" \
                                       --arg nextTitle "$NEXT_TITLE" \
                                       --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                                       '.current_major_task_index = $nextMajor |
                                        .current_major_task_file = $nextFile |
                                        .current_major_task_path = $nextPath |
                                        .current_sub_task_index = 0 |
                                        .completed_tasks = (.completed_tasks + 1) |
                                        .in_progress_tasks = 1 |
                                        .pending_tasks = (.pending_tasks - 1) |
                                        .current_task_summary = {
                                          "title": $nextTitle,
                                          "total_sub_tasks": $nextTotalSubs,
                                          "completed_sub_tasks": 0,
                                          "files_to_generate": []
                                        } |
                                        .last_updated = $timestamp' \
                                       "$PROGRESS_FILE" > "$MAIN_TEMP" && mv "$MAIN_TEMP" "$PROGRESS_FILE"

                                    echo -e "   ${GREEN}âœ… Advanced to task-${NEXT_MAJOR}: ${NEXT_TITLE}${NC}"
                                    git add "$PROGRESS_FILE"
                                fi
                            else
                                echo -e "   ${GREEN}ğŸ‰ğŸ‰ ALL TASKS COMPLETED! ğŸ‰ğŸ‰${NC}"

                                # Mark project as complete
                                FINAL_TEMP=$(mktemp)
                                jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                                   '.completed_tasks = .total_tasks |
                                    .in_progress_tasks = 0 |
                                    .pending_tasks = 0 |
                                    .project_completed = true |
                                    .completed_at = $timestamp |
                                    .last_updated = $timestamp' \
                                   "$PROGRESS_FILE" > "$FINAL_TEMP" && mv "$FINAL_TEMP" "$PROGRESS_FILE"

                                git add "$PROGRESS_FILE"
                            fi
                        fi
                    else
                        echo -e "   ${YELLOW}âš ï¸  Task file not found: ${TASK_FILE}${NC}"
                    fi

                    echo -e "   ${GREEN}âœ… All progress files staged for commit${NC}"
                else
                    echo -e "   ${GREEN}âœ“ Progress already up to date (sub-task index: ${CURRENT_SUB_INDEX})${NC}"
                fi
            else
                echo -e "   ${YELLOW}âš ï¸  Commit references task-${TASK_NUM} but current task is ${CURRENT_MAJOR_INDEX}${NC}"
                echo -e "   ${YELLOW}   This may indicate out-of-order task completion${NC}"
            fi
        else
            echo -e "   ${YELLOW}âš ï¸  No progress file found - skipping auto-update${NC}"
            echo -e "   ${YELLOW}   Checked: .claude, .goose, .cursor, .aider, .windsurf, .cline, .gemini, .projexlight${NC}"
        fi
    else
        echo -e "   ${YELLOW}âš ï¸  No sub-task number found in commit message${NC}"
        echo -e "   ${YELLOW}   Expected format: 'Complete task-N sub-task M: ...'${NC}"
    fi
else
    echo -e "   ${YELLOW}â„¹ï¸  No task reference in commit message - skipping progress update${NC}"
    echo -e "   ${YELLOW}   Expected format: 'Complete task-N sub-task M: ...'${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Success
echo -e "\n${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}âœ… Pre-commit scan passed${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e ""

exit 0
