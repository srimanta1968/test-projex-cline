#!/bin/bash

# ProjexLight MCP Pre-Push Hook (Cross-Platform)
# ============================================
# Triggers API testing and component duplication detection before git push
# This hook is installed automatically by the MCP server on startup
# Supports Windows (Git Bash/PowerShell), macOS, and Linux
#
# Exit codes:
#   0 = Push allowed
#   1 = Push blocked (server not running, build failed, etc.)

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
MCP_SERVER_URL="${MCP_SERVER_URL:-http://localhost:8766}"

# ============================================================
# Detect Operating System
# ============================================================
detect_os() {
    case "$(uname -s)" in
        Linux*)
            if grep -q Microsoft /proc/version 2>/dev/null; then
                echo "wsl"
            else
                echo "linux"
            fi
            ;;
        Darwin*)
            echo "macos"
            ;;
        CYGWIN*|MINGW*|MSYS*)
            echo "windows"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

OS_TYPE=$(detect_os)

# Set PROJECT_ROOT based on where the hook is running
if [ "$OS_TYPE" = "linux" ] && [ -d "/workspace" ]; then
    # Running inside Docker container
    PROJECT_ROOT="/workspace"
else
    # Running on host (Windows/Mac/WSL) - use git repository root
    PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
fi

echo -e "${BLUE}ğŸš€ ProjexLight Pre-Push Hook${NC}"
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "   OS Detected: ${GREEN}${OS_TYPE}${NC}"

# ============================================================
# STEP 1: Check if MCP server is running
# ============================================================
if ! curl -s "${MCP_SERVER_URL}/health" > /dev/null 2>&1; then
    echo -e "${YELLOW}âš ï¸  MCP server not running at ${MCP_SERVER_URL}${NC}"
    echo -e "${YELLOW}   Skipping API tests and component scanning${NC}"
    echo -e "${YELLOW}   Start MCP server: cd mcp-server && docker-compose up -d${NC}"
    exit 0
fi

echo -e "${GREEN}âœ“ MCP server is running${NC}"

# ============================================================
# STEP 2: Load server configuration (if available)
# ============================================================
CONFIG_FILE="${PROJECT_ROOT}/.projexlight/scripts/server-config.json"

# Select appropriate startup script based on OS
if [ "$OS_TYPE" = "windows" ]; then
    # Windows: prefer PowerShell script
    STARTUP_SCRIPT="${PROJECT_ROOT}/.projexlight/scripts/start-server.ps1"
    STARTUP_COMMAND="powershell.exe -ExecutionPolicy Bypass -File"
    if [ ! -f "$STARTUP_SCRIPT" ]; then
        STARTUP_SCRIPT="${PROJECT_ROOT}/.projexlight/scripts/start-server.bat"
        STARTUP_COMMAND=""
    fi
else
    # Unix/Linux/macOS: use bash script
    STARTUP_SCRIPT="${PROJECT_ROOT}/.projexlight/scripts/start-server.sh"
    STARTUP_COMMAND="bash"
fi

# ============================================================
# AUTO-DETECT PORT from .env file (PRIORITY 1)
# ============================================================
SERVER_PORT=""
DB_PORT=""
ENV_FILE=""

# Check common .env locations
for env_path in "$PROJECT_ROOT/.env" "$PROJECT_ROOT/server/.env" "$PROJECT_ROOT/backend/.env"; do
    if [ -f "$env_path" ]; then
        ENV_FILE="$env_path"
        break
    fi
done

if [ -n "$ENV_FILE" ]; then
    echo -e "\n${BLUE}ğŸ“‹ Reading configuration from .env file...${NC}"
    echo -e "   Location: ${GREEN}${ENV_FILE}${NC}"

    # Load ALL environment variables from .env file (make them available to subprocesses)
    set -a  # Enable export for all variables
    source "$ENV_FILE" 2>/dev/null || true
    set +a  # Disable export

    # Parse PORT from .env (handle various formats: PORT=3005, PORT = 3005, PORT="3005")
    if grep -q "^PORT[[:space:]]*=" "$ENV_FILE"; then
        SERVER_PORT=$(grep "^PORT[[:space:]]*=" "$ENV_FILE" | head -1 | sed 's/^PORT[[:space:]]*=[[:space:]]*//; s/"//g; s/'"'"'//g; s/#.*//; s/[[:space:]]*$//')
        export SERVER_PORT
        echo -e "   Server port: ${GREEN}${SERVER_PORT}${NC} (from .env)"
    fi

    # Parse DB_PORT from .env
    if grep -q "^DB_PORT[[:space:]]*=" "$ENV_FILE"; then
        DB_PORT=$(grep "^DB_PORT[[:space:]]*=" "$ENV_FILE" | head -1 | sed 's/^DB_PORT[[:space:]]*=[[:space:]]*//; s/"//g; s/'"'"'//g; s/#.*//; s/[[:space:]]*$//')
        export DB_PORT
        echo -e "   Database port: ${GREEN}${DB_PORT}${NC} (from .env)"
    fi
fi

# ============================================================
# LOAD PROJECT CONFIGURATION (PRIORITY 2)
# ============================================================
if [ -f "$CONFIG_FILE" ]; then
    echo -e "\n${BLUE}ğŸ“‹ Loading project configuration...${NC}"
    PROJECT_TYPE=$(jq -r '.project_type // "unknown"' "$CONFIG_FILE" 2>/dev/null || echo "unknown")
    FRAMEWORK=$(jq -r '.framework // "unknown"' "$CONFIG_FILE" 2>/dev/null || echo "unknown")

    # Only use config.json port if .env didn't provide one
    if [ -z "$SERVER_PORT" ]; then
        SERVER_PORT=$(jq -r '.server_port // 3000' "$CONFIG_FILE" 2>/dev/null || echo "3000")
        echo -e "   Server port: ${GREEN}${SERVER_PORT}${NC} (from config.json)"
    fi

    HEALTH_ENDPOINT=$(jq -r '.health_endpoint // "/health"' "$CONFIG_FILE" 2>/dev/null || echo "/health")

    echo -e "   Project type: ${GREEN}${PROJECT_TYPE}${NC}"
    echo -e "   Framework: ${GREEN}${FRAMEWORK}${NC}"
else
    # Fallback to environment variables or defaults
    if [ -z "$SERVER_PORT" ]; then
        SERVER_PORT="${BACKEND_PORT:-3000}"
        echo -e "\n${YELLOW}âš ï¸  No .env or config.json found${NC}"
        echo -e "${YELLOW}   Using default port: ${SERVER_PORT}${NC}"
    fi
    HEALTH_ENDPOINT="/health"
    PROJECT_TYPE="unknown"
    FRAMEWORK="unknown"
fi

# Full health endpoint URL
HEALTH_URL="http://localhost:${SERVER_PORT}${HEALTH_ENDPOINT}"

# ============================================================
# STEP 3: Check if local dev server is running
# ============================================================
echo -e "\n${BLUE}ğŸŒ Checking local development server...${NC}"

SERVER_RUNNING=false

# Try health endpoint first
if curl -s --max-time 5 "${HEALTH_URL}" > /dev/null 2>&1; then
    SERVER_RUNNING=true
    echo -e "${GREEN}âœ“ Server is running at ${HEALTH_URL}${NC}"
# Try just the port
elif curl -s --max-time 5 "http://localhost:${SERVER_PORT}" > /dev/null 2>&1; then
    SERVER_RUNNING=true
    echo -e "${GREEN}âœ“ Server is running on port ${SERVER_PORT}${NC}"
fi

# ============================================================
# STEP 4: If server not running, BLOCK PUSH
# ============================================================
if [ "$SERVER_RUNNING" = false ]; then
    echo -e "\n${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${RED}âŒ PUSH BLOCKED: Local development server is not running${NC}"
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "${YELLOW}API tests cannot be executed without a running server.${NC}"
    echo -e "${YELLOW}Please start your development server before pushing.${NC}"
    echo ""

    # Check if startup script exists
    if [ -f "$STARTUP_SCRIPT" ]; then
        echo -e "${BLUE}ğŸ“ To start the server, run:${NC}"
        if [ "$OS_TYPE" = "windows" ]; then
            echo -e "   ${STARTUP_COMMAND} \"${STARTUP_SCRIPT}\""
        else
            echo -e "   ${STARTUP_SCRIPT}"
        fi
        echo ""
        echo -e "${BLUE}This script will:${NC}"
        echo -e "   1. Load environment variables from .env"
        echo -e "   2. Install dependencies (if needed)"
        echo -e "   3. Build/compile the project"
        echo -e "   4. Start the development server"
        echo -e "   5. Verify it's running with health check"
        echo ""

        # Offer to run the script
        if [ "${PROJEXLIGHT_AUTO_START_SERVER:-false}" = "true" ]; then
            echo -e "${BLUE}ğŸš€ Auto-starting server...${NC}"

            # Execute startup script based on OS
            if [ "$OS_TYPE" = "windows" ]; then
                if [ -n "$STARTUP_COMMAND" ]; then
                    $STARTUP_COMMAND "$STARTUP_SCRIPT"
                    STARTUP_RESULT=$?
                else
                    "$STARTUP_SCRIPT"
                    STARTUP_RESULT=$?
                fi
            else
                "$STARTUP_SCRIPT"
                STARTUP_RESULT=$?
            fi

            if [ $STARTUP_RESULT -eq 0 ]; then
                SERVER_RUNNING=true
                echo -e "${GREEN}âœ“ Server started successfully${NC}"
            else
                EXIT_CODE=$STARTUP_RESULT
                echo -e "${RED}âŒ Server startup failed (exit code: $EXIT_CODE)${NC}"

                case $EXIT_CODE in
                    1)
                        echo -e "${RED}   Problem: Dependency installation failed${NC}"
                        echo -e "${YELLOW}   Fix: Check npm/pip/composer dependencies${NC}"
                        ;;
                    2)
                        echo -e "${RED}   Problem: Build/compilation failed${NC}"
                        echo -e "${YELLOW}   Fix: Resolve syntax/type errors before pushing${NC}"
                        ;;
                    3)
                        echo -e "${RED}   Problem: Server failed to start${NC}"
                        echo -e "${YELLOW}   Fix: Check configuration and environment variables${NC}"
                        ;;
                    4)
                        echo -e "${RED}   Problem: Health check failed${NC}"
                        echo -e "${YELLOW}   Fix: Server started but not responding correctly${NC}"
                        ;;
                esac

                echo ""
                echo -e "${YELLOW}Check logs: ${PROJECT_ROOT}/.projexlight/logs/server-startup.log${NC}"
                exit 1
            fi
        else
            echo -e "${YELLOW}To enable auto-start: export PROJEXLIGHT_AUTO_START_SERVER=true${NC}"
            echo ""
        fi
    else
        # No startup script, provide manual instructions
        echo -e "${BLUE}ğŸ“ Please start your server manually:${NC}"

        case "$PROJECT_TYPE" in
            node|monorepo)
                echo -e "   ${YELLOW}npm run dev${NC}  or  ${YELLOW}npm start${NC}"
                ;;
            python)
                case "$FRAMEWORK" in
                    FastAPI)
                        echo -e "   ${YELLOW}uvicorn main:app --reload${NC}"
                        ;;
                    Flask)
                        echo -e "   ${YELLOW}flask run${NC}"
                        ;;
                    Django)
                        echo -e "   ${YELLOW}python manage.py runserver${NC}"
                        ;;
                    *)
                        echo -e "   ${YELLOW}python main.py${NC}  or  ${YELLOW}python app.py${NC}"
                        ;;
                esac
                ;;
            java)
                echo -e "   ${YELLOW}mvn spring-boot:run${NC}  or  ${YELLOW}gradle bootRun${NC}"
                ;;
            go)
                echo -e "   ${YELLOW}go run main.go${NC}"
                ;;
            *)
                echo -e "   ${YELLOW}Start your development server on port ${SERVER_PORT}${NC}"
                ;;
        esac

        echo ""
    fi

    # Final check if server was auto-started
    if [ "$SERVER_RUNNING" = false ]; then
        echo -e "${RED}Push blocked until server is running.${NC}"
        echo ""
        echo -e "${YELLOW}To bypass (NOT RECOMMENDED): git push --no-verify${NC}"
        exit 1
    fi
fi

# ============================================================
# STEP 5: Get changed files
# ============================================================
echo -e "\n${BLUE}ğŸ“‹ Identifying changed files...${NC}"

# Read pre-push hook input (local_ref local_sha remote_ref remote_sha)
while read local_ref local_sha remote_ref remote_sha; do
    # Check if this is a new branch (remote_sha is all zeros)
    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        echo -e "   ${BLUE}New branch detected - analyzing all commits${NC}"
        # New branch: get all files in commits being pushed
        # Compare against empty tree to get all files
        CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r $local_sha 2>/dev/null || git diff --name-only 4b825dc642cb6eb9a060e54bf8d69288fbee4904..$local_sha 2>/dev/null || git ls-files)
    else
        # Existing branch: get files changed since remote
        CHANGED_FILES=$(git diff --name-only $remote_sha..$local_sha 2>/dev/null || echo "")
    fi
done

# Fallback: if no input from pre-push hook (shouldn't happen, but just in case)
if [ -z "$CHANGED_FILES" ]; then
    REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
    if [ -n "$REMOTE_BRANCH" ]; then
        # Has upstream tracking branch
        CHANGED_FILES=$(git diff --name-only ${REMOTE_BRANCH}..HEAD 2>/dev/null || echo "")
    else
        # No upstream - might be first push
        echo -e "   ${YELLOW}No upstream branch found - analyzing all tracked files${NC}"
        CHANGED_FILES=$(git diff --name-only --cached 2>/dev/null || git ls-files)
    fi
fi

if [ -z "$CHANGED_FILES" ]; then
    echo -e "${YELLOW}âš ï¸  No changed files detected${NC}"
    echo -e "${YELLOW}   Skipping API tests and component scanning${NC}"
    exit 0
fi

# Count unique changed files
FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
echo -e "${GREEN}âœ“ Found ${FILE_COUNT} changed files${NC}"

# Convert to JSON array
CHANGED_FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')

# ============================================================
# STEP 6: Run API tests
# ============================================================
echo -e "\n${BLUE}ğŸ§ª Running API tests on changed files...${NC}"

API_TEST_RESULT=$(curl -s -X POST "${MCP_SERVER_URL}/api/test" \
    -H "Content-Type: application/json" \
    -d "{
        \"project_root\": \"/workspace\",
        \"triggered_by\": \"git_push\",
        \"changed_files\": ${CHANGED_FILES_JSON},
        \"local_server_running\": true,
        \"local_server_port\": ${SERVER_PORT},
        \"project_type\": \"${PROJECT_TYPE}\"
    }" 2>&1)

if [ $? -eq 0 ] && [ -n "$API_TEST_RESULT" ]; then
    # Parse test results
    TOTAL_APIS=$(echo "$API_TEST_RESULT" | jq -r '.summary.totalAPIs // 0' 2>/dev/null || echo "0")
    NEW_APIS=$(echo "$API_TEST_RESULT" | jq -r '.summary.newAPIs // 0' 2>/dev/null || echo "0")
    MODIFIED_APIS=$(echo "$API_TEST_RESULT" | jq -r '.summary.modifiedAPIs // 0' 2>/dev/null || echo "0")
    PASSED=$(echo "$API_TEST_RESULT" | jq -r '.summary.passedAPIs // 0' 2>/dev/null || echo "0")
    FAILED=$(echo "$API_TEST_RESULT" | jq -r '.summary.failedAPIs // 0' 2>/dev/null || echo "0")
    BLOCKING_CONFLICTS=$(echo "$API_TEST_RESULT" | jq -r '.summary.blockingConflicts // 0' 2>/dev/null || echo "0")
    DUPLICATE_WARNINGS=$(echo "$API_TEST_RESULT" | jq -r '.summary.duplicateWarnings // 0' 2>/dev/null || echo "0")
    SKIPPED=$(echo "$API_TEST_RESULT" | jq -r '.summary.skippedAPIs // 0' 2>/dev/null || echo "0")

    echo -e "${GREEN}âœ“ API Testing completed${NC}"
    echo -e "  Total APIs discovered: ${TOTAL_APIS}"
    echo -e "  New APIs: ${GREEN}${NEW_APIS}${NC}"

    if [ "$MODIFIED_APIS" -gt 0 ]; then
        echo -e "  Modified APIs: ${BLUE}${MODIFIED_APIS}${NC}"
    fi

    echo -e "  Tests passed: ${GREEN}${PASSED}${NC}"

    if [ "$FAILED" -gt 0 ]; then
        echo -e "  Tests failed: ${RED}${FAILED}${NC}"

        # Show failed test details
        FAILED_ENDPOINTS=$(echo "$API_TEST_RESULT" | jq -r '.failedTests[]? | "   - \(.method) \(.endpoint): \(.errorMessage)"' 2>/dev/null || echo "")
        if [ -n "$FAILED_ENDPOINTS" ]; then
            echo -e "${RED}  Failed tests:${NC}"
            echo "$FAILED_ENDPOINTS"
        fi
    fi

    if [ "$SKIPPED" -gt 0 ]; then
        echo -e "  Tests skipped: ${YELLOW}${SKIPPED}${NC}"
    fi

    if [ "$BLOCKING_CONFLICTS" -gt 0 ]; then
        echo -e "  ${RED}ğŸš¨ Blocking conflicts: ${BLOCKING_CONFLICTS}${NC}"
    fi

    if [ "$DUPLICATE_WARNINGS" -gt 0 ]; then
        echo -e "  ${YELLOW}âš ï¸  Duplicate warnings: ${DUPLICATE_WARNINGS}${NC}"
    fi

    # BLOCK push if there are conflicting APIs
    if [ "$BLOCKING_CONFLICTS" -gt 0 ]; then
        echo -e "\n${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${RED}âŒ PUSH BLOCKED: ${BLOCKING_CONFLICTS} conflicting API(s) detected${NC}"
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -e "${YELLOW}You have created APIs that conflict with existing endpoints:${NC}"
        echo ""

        # Show conflict details
        CONFLICT_DETAILS=$(echo "$API_TEST_RESULT" | jq -r '.duplicateAPIsDetected[]? | select(.blocking == true) | "   - \(.newAPI.method) \(.newAPI.endpoint) in \(.newAPI.routeFilePath)\n     Conflicts with existing API in \(.existingAPI.routeFilePath)\n     Action: \(.recommendation)"' 2>/dev/null || echo "")
        if [ -n "$CONFLICT_DETAILS" ]; then
            echo -e "${CONFLICT_DETAILS}"
        fi

        echo ""
        echo -e "${YELLOW}Please resolve conflicts by:${NC}"
        echo -e "  1. Renaming the new API to a different endpoint"
        echo -e "  2. Removing the new API and using the existing one"
        echo ""
        echo -e "${YELLOW}To bypass (NOT RECOMMENDED): git push --no-verify${NC}"
        exit 1
    fi

    # Optionally fail push if tests failed
    if [ "$FAILED" -gt 0 ] && [ "${PROJEXLIGHT_FAIL_ON_TEST_FAILURE:-true}" = "true" ]; then
        echo -e "\n${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo -e "${RED}âŒ Push blocked: ${FAILED} API test(s) failed${NC}"
        echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        echo ""
        echo -e "${YELLOW}Fix the failing tests before pushing.${NC}"
        echo -e "${YELLOW}To bypass: export PROJEXLIGHT_FAIL_ON_TEST_FAILURE=false${NC}"
        exit 1
    fi
else
    echo -e "${YELLOW}âš ï¸  API testing returned no results${NC}"
fi

# ============================================================
# STEP 7: Component duplication scan
# ============================================================
echo -e "\n${BLUE}ğŸ” Scanning for duplicate components in changed files...${NC}"

COMPONENT_SCAN_RESULT=$(curl -s -X POST "${MCP_SERVER_URL}/api/components/scan" \
    -H "Content-Type: application/json" \
    -d "{
        \"project_root\": \"/workspace\",
        \"triggered_by\": \"git_push\",
        \"changed_files\": ${CHANGED_FILES_JSON}
    }" 2>&1)

if [ $? -eq 0 ] && [ -n "$COMPONENT_SCAN_RESULT" ]; then
    DUPLICATES_FOUND=$(echo "$COMPONENT_SCAN_RESULT" | jq -r '.summary.duplicateComponentsFound // 0' 2>/dev/null || echo "0")

    echo -e "${GREEN}âœ“ Component scan completed${NC}"

    if [ "$DUPLICATES_FOUND" -gt 0 ]; then
        echo -e "  ${YELLOW}âš ï¸  Similar components found: ${DUPLICATES_FOUND}${NC}"
        echo -e "  ${YELLOW}   Review details in Leadership Dashboard${NC}"
    else
        echo -e "  No duplicate components detected"
    fi
else
    echo -e "${YELLOW}âš ï¸  Component scan returned no results${NC}"
fi

# ============================================================
# STEP 8: Summary
# ============================================================
echo -e "\n${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}âœ… Pre-push checks completed successfully${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BLUE}ğŸ“Š View detailed results in Leadership Dashboard${NC}"
echo ""

exit 0
